---
layout: post
title: Virtual Memory: Address Spaces
date: 2020-12-06 09:00:00 +0300
description: Notes on virtual memory. # Add post description (optional)
img: addressspace.png # Add image post (optional)
tags: [OS,Memory,Virtual Memory, Address Spaces] # add tag
---
# Every address generated by a user program is a virtual address.

The OS is just providing an illusion to each process that it has its own large and private memory. With some hardware help, the OS will turn these pretend virtual addresses into real physical addresses and thus is able to locate the desired information.

### Why would we want the OS to provide this illusion?

Mostly ease of use. As a programmer, you never have to worry about things like "where do i need to store this variable", because the virtual addres pace of the program is large and has lots of room for that sort of thing. You dont want to think about difficult problems such as implementing time sharing efficiently.
Another important factor is protection. The OS should make sure to protect processes from one another as well as the OS itself from processes. When one process performs a load, store or an instruction fetch, it should not be able to access or affect in any way the memory contents of another process or the OS itself. Protection enables the property of isolation among processes.

### Hence Address Space.

The address space of a process contains all memory state of each process. We can generally think of it as being composed by code ( the instructions of a program ), stack ( to keep track of where it is in the function call chain as well as allocate local variables and pass parameters to and from routines ) and the heap ( used fir dynamically-allocated, user managed memory ). These two last regions can grow in opposite directions.

The stack and the heap are structured in different ways. The stack stores values in the order it gets them and removes the values in opposite order (LIFO). All data stored on the stack must have a known fixed size. The heap is less organized: when we put data on the heap, we request a certain amount of space on the heap and receive a pointer which is stored on the stack(has a fixed, known size). From this notion, it becomes clear that accessing and storing on the stack is faster than on the heap.

### Address Translation

To use this illusion we'll need some sort of address translation, where the virtual address provided by the instruction is changed into a physical address where the desired information is actually located.

One particular form of virtualization is dynamic relocation ( also known as base-and-bounds ). Using two hardwate registers within the CPU ( base register and limit/bounds register ) we are allowed to place the address space anywhere we'd like in physical memory while ensuring that the process only access its own address space.
When a process is runningm any memory reference generated is translated in the following manner:

 - physical address = virtual address + base

 bounds register is there to help with protection, i.e, the processor will check that the memory reference is within bounds to make sure it is legal. This part of the processor that helps with translation is called MMU (memory management unit).

### Strategies for space-management problem : Segmentation

 Dynamic allocation does have inneficiencies. When a process allocates memory, and the stack and heap are not too big, all the space between them is simply wasted. We call this type of waste, internal fragmentation.

 In attempt to solve this problem, an idea of Segmentation was born. In theory the idea is simple: instead of having just one base and bounds pair in the MMU, why not have a base and bound pair per logical segment of the address space.

 Lets see an example of how this could be implemented.

 Imagine that we have the following address space:

 -- image

 with the following physical memory:

 -- image

 On the MMU, you would have the following segment register values:

    Segment      Base    Size
    Code         32K     2K
    Heap         34K     2K
    Stack        28K     2K

 Now lets do an example translation. Assume a reference is made to virtual address 4200 (heap segment). By adding virtual address 4200 to the base register of the heap (34K) we get the physical address 39016. With segments we need to first extract the offset into the heap, i.e, which byte/s in this segment the address refers to. As the heap starts at 4K (4096), the offset is actually 4200-4096=104. When we add it to the base register we get the desired result: 34K + 104 = 34920.

The stack would use the same logic but with one critical difference: it grows backwards.

The hardware needs therefore to understand that segments can grow in negative and positive directions, and perform translation in a slightly different manner. It will use a bit to know if a segment grows in positive or negative direction( 1 for positive, 0 for negative ).

An updated view of segment register values could be thought as:

    Segment      Base    Size   Grows Positive
    Code         32K     2K     1
    Heap         34K     2K     1
    Stack        28K     2K     0


Let's imagine now we wanted to access virtual address 15K (mapped to physical address 27K). Our virtual address in binary is 11 1100 0000 0000 (hex 0x3C00). The hardware uses the top two bits to designate the segment and the rest (3K) as offset. To obtain the correct negative offset, we must subtrack the maximum segment size from 3K. In a case of maximum segment 4K this is equivalent to 3K-4K = -1K. If we add this value to base, we arreive to the correct physical address 27K.

 What would happen if we refered to an illegal address such as 7K? the hardware detects that the address is out of bounds, traps the OS, which will likely origin the infamous segmentation violation or segmentation fault.

Segmentation provides huge savings of physical memory but it also raises new issues:

 - OS on a context switch must be able to save and restore segment registers. It must make sure to set up these registers cprrectly before letting the process run again.
 - OS must manage free space in physical memory. When a new address space is created, the OS has to be able to find space in physical memory for its segments. The general problem that arises is that physical memory quickly becomes full of little holes of free space, making it difficult to allocate new segments or grow existing ones. This is generally refered as external fragmentation.

### Strategies for space-management problem : Paging.

Other approach considering is to chop up space into fixed-sized



<!-- /* This blog was originally posted on [Medium](https://medium.com/@seomisw/image-dataset-for-litter-detection-7f1cab9e7fa1){:target="_blank"}--be sure to follow and clap! */ -->
